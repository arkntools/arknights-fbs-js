// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { clz_Torappu_MapData_Edge, clz_Torappu_MapData_EdgeT } from './clz-torappu-map-data-edge.js';
import { clz_Torappu_MapEffectData, clz_Torappu_MapEffectDataT } from './clz-torappu-map-effect-data.js';
import { clz_Torappu_TileData, clz_Torappu_TileDataT } from './clz-torappu-tile-data.js';
import { hg__internal__MapData, hg__internal__MapDataT } from './hg--internal--map-data.js';


export class clz_Torappu_MapData implements flatbuffers.IUnpackableObject<clz_Torappu_MapDataT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):clz_Torappu_MapData {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsclz_Torappu_MapData(bb:flatbuffers.ByteBuffer, obj?:clz_Torappu_MapData):clz_Torappu_MapData {
  return (obj || new clz_Torappu_MapData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsclz_Torappu_MapData(bb:flatbuffers.ByteBuffer, obj?:clz_Torappu_MapData):clz_Torappu_MapData {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new clz_Torappu_MapData()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

map(obj?:hg__internal__MapData):hg__internal__MapData|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? (obj || new hg__internal__MapData()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
}

tiles(index: number, obj?:clz_Torappu_TileData):clz_Torappu_TileData|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new clz_Torappu_TileData()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

tilesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

blockEdges(index: number, obj?:clz_Torappu_MapData_Edge):clz_Torappu_MapData_Edge|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new clz_Torappu_MapData_Edge()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

blockEdgesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

tags(index: number):string
tags(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
tags(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

tagsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

effects(index: number, obj?:clz_Torappu_MapEffectData):clz_Torappu_MapEffectData|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new clz_Torappu_MapEffectData()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

effectsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

layerRects(index: number):string
layerRects(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
layerRects(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

layerRectsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startclz_Torappu_MapData(builder:flatbuffers.Builder) {
  builder.startObject(6);
}

static addMap(builder:flatbuffers.Builder, mapOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, mapOffset, 0);
}

static addTiles(builder:flatbuffers.Builder, tilesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, tilesOffset, 0);
}

static createTilesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTilesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addBlockEdges(builder:flatbuffers.Builder, blockEdgesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, blockEdgesOffset, 0);
}

static createBlockEdgesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startBlockEdgesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addTags(builder:flatbuffers.Builder, tagsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, tagsOffset, 0);
}

static createTagsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTagsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addEffects(builder:flatbuffers.Builder, effectsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, effectsOffset, 0);
}

static createEffectsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEffectsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLayerRects(builder:flatbuffers.Builder, layerRectsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, layerRectsOffset, 0);
}

static createLayerRectsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLayerRectsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endclz_Torappu_MapData(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createclz_Torappu_MapData(builder:flatbuffers.Builder, mapOffset:flatbuffers.Offset, tilesOffset:flatbuffers.Offset, blockEdgesOffset:flatbuffers.Offset, tagsOffset:flatbuffers.Offset, effectsOffset:flatbuffers.Offset, layerRectsOffset:flatbuffers.Offset):flatbuffers.Offset {
  clz_Torappu_MapData.startclz_Torappu_MapData(builder);
  clz_Torappu_MapData.addMap(builder, mapOffset);
  clz_Torappu_MapData.addTiles(builder, tilesOffset);
  clz_Torappu_MapData.addBlockEdges(builder, blockEdgesOffset);
  clz_Torappu_MapData.addTags(builder, tagsOffset);
  clz_Torappu_MapData.addEffects(builder, effectsOffset);
  clz_Torappu_MapData.addLayerRects(builder, layerRectsOffset);
  return clz_Torappu_MapData.endclz_Torappu_MapData(builder);
}

unpack(): clz_Torappu_MapDataT {
  return new clz_Torappu_MapDataT(
    (this.map() !== null ? this.map()!.unpack() : null),
    this.bb!.createObjList<clz_Torappu_TileData, clz_Torappu_TileDataT>(this.tiles.bind(this), this.tilesLength()),
    this.bb!.createObjList<clz_Torappu_MapData_Edge, clz_Torappu_MapData_EdgeT>(this.blockEdges.bind(this), this.blockEdgesLength()),
    this.bb!.createScalarList<string>(this.tags.bind(this), this.tagsLength()),
    this.bb!.createObjList<clz_Torappu_MapEffectData, clz_Torappu_MapEffectDataT>(this.effects.bind(this), this.effectsLength()),
    this.bb!.createScalarList<string>(this.layerRects.bind(this), this.layerRectsLength())
  );
}


unpackTo(_o: clz_Torappu_MapDataT): void {
  _o.map = (this.map() !== null ? this.map()!.unpack() : null);
  _o.tiles = this.bb!.createObjList<clz_Torappu_TileData, clz_Torappu_TileDataT>(this.tiles.bind(this), this.tilesLength());
  _o.blockEdges = this.bb!.createObjList<clz_Torappu_MapData_Edge, clz_Torappu_MapData_EdgeT>(this.blockEdges.bind(this), this.blockEdgesLength());
  _o.tags = this.bb!.createScalarList<string>(this.tags.bind(this), this.tagsLength());
  _o.effects = this.bb!.createObjList<clz_Torappu_MapEffectData, clz_Torappu_MapEffectDataT>(this.effects.bind(this), this.effectsLength());
  _o.layerRects = this.bb!.createScalarList<string>(this.layerRects.bind(this), this.layerRectsLength());
}
}

export class clz_Torappu_MapDataT implements flatbuffers.IGeneratedObject {
constructor(
  public map: hg__internal__MapDataT|null = null,
  public tiles: (clz_Torappu_TileDataT)[] = [],
  public blockEdges: (clz_Torappu_MapData_EdgeT)[] = [],
  public tags: (string)[] = [],
  public effects: (clz_Torappu_MapEffectDataT)[] = [],
  public layerRects: (string)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const map = (this.map !== null ? this.map!.pack(builder) : 0);
  const tiles = clz_Torappu_MapData.createTilesVector(builder, builder.createObjectOffsetList(this.tiles));
  const blockEdges = clz_Torappu_MapData.createBlockEdgesVector(builder, builder.createObjectOffsetList(this.blockEdges));
  const tags = clz_Torappu_MapData.createTagsVector(builder, builder.createObjectOffsetList(this.tags));
  const effects = clz_Torappu_MapData.createEffectsVector(builder, builder.createObjectOffsetList(this.effects));
  const layerRects = clz_Torappu_MapData.createLayerRectsVector(builder, builder.createObjectOffsetList(this.layerRects));

  return clz_Torappu_MapData.createclz_Torappu_MapData(builder,
    map,
    tiles,
    blockEdges,
    tags,
    effects,
    layerRects
  );
}
}
